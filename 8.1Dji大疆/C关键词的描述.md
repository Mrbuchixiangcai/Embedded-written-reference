## C关键词的描述

| 关键字   | 特征                                               | 应用                                                 |
| -------- | -------------------------------------------------- | ---------------------------------------------------- |
| const    | 运行时，表示**只读**                               | 修饰常量，指针                                       |
| static   | 编译时分配空间，**静态**全局变量                   | 修饰变量，函数                                       |
| volatile | 编译时不优化：从内存中取值，不是寄存器中           | 多线程访问一个全局变量时                             |
| sizeof   | 编译时：计算                                       | 计算**类型**占用的空间大小                           |
| strlen   | 运行时：计算                                       | 计算字符串的**长度**，不是类型占内存的大小           |
| assert   | 运行时：断言--是**宏**，不是函数；                 | 如果条件错误，则终止程序执行；                       |
| extern   | 编译时：扩展声明                                   | 声明全局变量/函数；                                  |
| Union    | **共享**内存空间，任意时刻只有一个数据成员可以有值 | 计算内存字节的空间时，以最大值为准                   |
| typedef  | 运行时：类型重定义..可以重定义类型                 | 定义函数指针                                         |
| #define  | **预编译**时：宏定义                               | 定义频繁使用的短小函数，在预编译的时候直接**替换**； |

1. const 与 #define相比？
   + const 常量有**数据类型**，而宏常量没有数据类型
   + **编译器**可以对前者进行类型安全**检查**。而对后者只进行**字符替换**，没有类型安全检查，并且在字符替换可能会产生意料不到的错误
   + 集成化的**调试**工具可以对const 常量进行调试，但是不能对宏常量进行调试。
2. inline和#define对比
   + inline代码放入**预编译器**符号表中，高效；它是个真正的**函数**，调用时有严格的**参数检测**。

### const  ： 只读

+ 被const修饰的就只能读：**常**整形数，**常**指针；
+ const修饰的变量为只读变量，定义一个const类型的变量时必须完成**初始化** 

```
Const int a; 		// a是一个常量整形，值不能修改
int const a;		 // 同上
const int *a; 		// a是一个**指向常整型数的指针**；整型数是不可修改的，但指针可以
int	const *a;		//同上
int * const a; 		// a **指向整型数的常指针**；指针指向的整型数是可以修改的，但指针是不可修改
const int * const a; 
int const * const a  	//a是一个**指向常整型数的常指针**；指针指向的整型数是不可修改的，同时指针也是不可修改的
```

1. const的作用？
   + 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。
   + 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 
   + 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。

### static

1.  在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 
2.  在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 
3. 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 
   

### volatile

```
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用**volatile 告诉编译器不应对这样的对象进行优化**
- volatile 关键字声明的变量，每次访问时都必须从**内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （volatile实在编译阶段，const是在使用的阶段）
- 指针可以是 volatile（）

### sizeof() 和 strlen()区别

- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。4bytes

+ sizeof()是运算符，由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。
  + sizeof返回值：跟这些里面所存储的内容没有关系
  + strlen是函数，它的结果要在运行的时候才能计算出来，用来计算字符串的长度，不是类型占内存的大小。

### assert()

+ 断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

### extern "C"

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的

+ `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

### union 联合

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

### typedef and define

1. typedef 的优势

   ```
   #define dPS struct s * 			// 宏定义 dPS 表示 struct s*
   typedef struct s * tPS;			// typedef 表示，将struct *s 重命名为tPS
   ```

   + 在定义指针变量的时候，哪种方式更好？使用typedef更好；

   ```
   dPS p1,p2;		-->		扩展为：struct s *p1, p2;  	// 此时只定义了一个指针类型的p1， 另外一个不是；
   tPS p3,p4;		--> 两个都是指针
   ```

