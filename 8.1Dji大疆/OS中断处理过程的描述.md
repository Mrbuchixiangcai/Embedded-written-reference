## 简述处理器中断处理的过程

###  中断服务程序需要满足如下要求：
+ (1)不能返回值；
+ (2)不能向ISR传递参数；
+ (3) ISR应该尽可能的短小精悍； --- 不进行浮点类型的计算
+ (4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。

```
// 新的关键字__interrupt, 让标准C支持中断；
// 定义了一个ISR中断服务程序，查找其中的错误；
__interrupt double compute_area (double radius) 	（1）不能进行传参
{ 
	double area = PI * radius * radius; 									(2)  在许多的处理器/编译器中，浮点一般都是不可重入的。
	printf(” Area = %f”, area); 											（3）printf()经常有重入和性能上的问题
	return area; 																			（4） 中断不允许返回值的
}
```

### 中断的定义

1. CPU在正常执行程序的时候, 由于外部/内部事件的**触发**, 或者程序预先设定的**系统调用**; 
2.  引起CPU暂时**中止**当前正在执行的程序, **保存**被中断程序相关信息到栈中, **转而去处理**外部/内部事件, 或者程序预先设定的中断服务子程序;
3. 待执行完ISR后, CPU**获取**保存在栈中被中断的程序信息, **继续执行**被中断的程序, 这一过程就叫做中断;

### 中断的几个概念

1. 中断向量: 中断服务程序ISR的**入口地址**;
2. 中断向量表:  把系统中所有的**中断类型码**及其对应的**中断向量**按一定的**规律存放**在一个区域内，这个存储区域就叫做中断向量表；
3. 中断源: 软中断/内中断(软件中断)、外中断/硬件中断、异常等。

### 中断处理过程

+ 中断请求→中断响应→保护现场→中断服务→恢复现场→中断返回
+ cpu接受终端->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文。

1. 中断请求
   + 当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断控制系统的中断请求触发器置位，向CPU请求中断。
   + 系统要求中断请求信号一直保持到CPU对其进行中断响应为止；
2. 中断响应
   + 内部中断源: CPU必须响应，而且**自动取得**中断服务子程序的入口地址，执行中断服务子程序。
   + 外部中断源: CPU在执行当前指令的最后一个时钟周期去**查询INTR引脚**;
     + 若查询到中断请求信号有效，同时在系统开中断（即IF=1）的情况下
     + CPU向发出中断请求的外设回送一个**低电平**有效的**中断应答信号**，作为对中断请求INTR的应答，系统自动进入中断响应周期；
3. 保护现场
   + 主程序和中断服务子程序都要使用CPU内部寄存器等资源，为使中断处理程序不破坏主程序中寄存器的内容，应**先将断点处各寄存器的内容压入堆栈保护起来**
     + 主要是**当前IP**: 将要执行的下一条地址
     + **CS值**: 代码段地址，再进入的中断处理。
   + 现场保护是由**用户**使用**PUSH**指令来实现的；
4. 中断服务
   + 中断服务是执行中断的主体部分，不同的中断请求，有各自不同的中断服务内容，需要根据中断源所要完成的功能;
   + 事先编写相应的中断服务子程序存入内存，等待中断请求响应后调用执行；
5. 恢复现场
   + 当中断处理完毕后，用户通过**POP指令**将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值。
6. 中断返回
   + 在中断服务子程序的最后要安排一条**中断返回指令IRET**（interrupt return），
   + 执行该指令，系统自动将堆栈内保存的 IP和CS值**弹出**，从而恢复主程序断点处的地址值，
   + 同时还自动恢复**标志寄存器FR或EFR**的内容，使CPU转到被中断的程序中**继续执行**。
     

### 中断响应中的寄存器

+ IP两个寄存器, 指示了 CPU 当前将要读取的指令的地址
  + 其中CS为**代码段**寄存器，
  + 而IP为**指令指针**寄存器。
  + 可以简单地认为，CS段地址，IP是偏移地址。
+ RET：也可以叫做**近返回**，即段内返回。
  + 处理器从堆栈中弹出IP或者EIP，然后根据当前的CS：IP跳转到新的执行地址。
  + 如果之前压栈的还有其余的参数，则这些参数也会被弹出；
+ RETF：也叫**远返回**，从一个段返回到另一个段。
  + 先弹出堆栈中的IP/EIP，然后弹出CS，有之前压栈的参数也会弹出。（近跳转与远跳转的区别就在于CS是否压栈）；
+ IRET：用于从中断返回，会弹出IP/EIP，然后CS，以及一些标志。然后从CS：IP执行。
  
