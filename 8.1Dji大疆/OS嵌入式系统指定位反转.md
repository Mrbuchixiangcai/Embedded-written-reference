## 嵌入式OS位运算

1. 写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3；保持其让的位不变

   ```
   #define BIT3 (0x1<<3) 
   static int a; 
   void set_bit3(void) 
   { 
   		a |= BIT3; 
   } 
   void clear_bit3(void) 
   { 
   		a &= ~BIT3; 
   } 
   ```

   

### OS系统中的位运算

1. OS多任务嵌入式系统中，有一个CPU可直接寻址的32位寄存器REGn，地址为0x1F000010，编写一个安全的函数，将寄存器REGn的指定位反转（要求保持其他bit的值不变)

   ```
   void bit_reverse(uint32_t nbit)
   {
       *((volatile unsigned int *)0x1F000010) ^= (0x01 << nbit);	// (volatile unsigned int *)0x1F000010 相当于强制转换；
   }
   ```

2. OS系统中的位运算

   + 特定位清零用  &
   + 特定位置1用     |
   + 特定位取反用  ^

## 位运算

1. 按位与运算符（&）

   - 只有两个数的二进制**同时为1，结果才为1**，否则为0。（负数按补码形式参加按位与运算）

   - ```
     0 & 0= 0 ，0 & 1= 0，1 & 0= 0， 1 & 1= 1
     ```

2. 按位或运算符（ | ）

   - 参加运算的两个数，只要其中一个为1，结果就为1

   - ```
      0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 
     ```

3. 异或运算符（ ^ ）

   - 参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0

   - ```
     0 ^ 0=0  ， 0 ^ 1= 1  ， 1 ^ 0= 1  ， 1 ^ 1= 0
     ```

### 异或运算符的特殊作用：

1. 与1异或：特点位反转

   ```
   X=10101110，使X低4位翻转，用X ^0000 1111 = 1010 0001即可得到
   0 ^1 = 1; 1^1 = 0;
   ```

2. 与0异或：保留原值

   ```
   X ^ 00000000 = 1010 1110。
   0 ^ 0 = 0; 1 ^ 0 = 1;
   ```

3. 异或运算的性质

   - 异或其实就是**不进位加法**
     - 如：1+1=0，0+0=0,1+0=1
   - 自反性:  
     - a^b^b=a^0=a;

### 左移运算符(<<) 和 右移运算符(>>)

1. 左移运算符
   + 将一个运算对象的各二进制位全部左移若干位
   + 左边的二进制位丢弃，右边补0
   + 则每左移一位，相当于该数乘以2
2. 右移运算符
   + 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃
   + 每右移一位，相当于该数除以2
3. 正数和负数
   + 正数：位不足时，左边补0；
   + 负数：位不足时，左边补1；

### [位运算的题目](https://blog.csdn.net/sinat_35121480/article/details/53510793)