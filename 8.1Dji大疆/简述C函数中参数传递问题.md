## 简述C函数中参数传递问题?

### 问题一: C函数中参数如何传递（__cdecl调用方式）

1. 什么是函数调用约定？

   + 函数的调用: 会发生参数的传递和值的返回; 函数调用完后, 会释放的分配的内存空间;
   + **函数调用约定作用**: 描述**参数的传递**过程，决定由调用者(被调用者)**平衡堆栈**;
     + (1) 决定了发生函数调用时函数**参数的入栈顺序**
     + (2)决定由**调用者函数**(被调用函数)负责**清除栈**中的参数，还原堆栈;

2. 常见的函数调用约定有哪些?

   + 按参数的**传递顺序**对这些约定可划分:  (栈: 从上到下入栈?)
   + 从右到左依次入栈：__ stdcall (C++)，__ cdecl (C)，__thiscall；
   + 从左到右依次入栈：__ pascal，__fastcall。

3. * __cdecl**函数调用约定?

   + **__cdecl**：C Declaration的缩写（declaration，声明）表示C语言默认的函数调用方法;
     + **入栈顺序:**  所有参数从右到左依次入栈，
     + **调用者函数:**　由调用者负责把参数压入栈，最后也是由调用者负责清除栈的内容 ；
   + __stdcall：是StandardCall的缩写，是C++的标准调用方式
     + 特征类似；

4.  **可变参数**的函数调用约定如何选择？

   + 要求: **带有可变参数的函数必须是__cdecl调用约定**
   + 例如: printf

### [问题二: C语言返回值如何传递?](https://blog.csdn.net/qq_33921804/article/details/52663212)

1. 函数返回值为什么一般放在**寄存器**中？

   + 如果放在堆栈中: 有可能因为中断而被覆盖。
   + esp 寄存器总是指向栈顶（低地址），ebp指向栈底（高地址）
     + 栈的增长方向：由高地址--向低地址

2. C语言返回值通过哪个寄存器传递?

   + 一般情况: 通过**eax**进行传递的，但是eax只能存储**4个字节**的信息; (返回值不会太大)
   + 返回值大小为**M字节**
     + M <= 4字节，将返回值存储在eax返回；
     + 4 < M <=8，把eax，edx联合起来。其中，edx存储高位，eax存储**低位**；
     + [M > 8，如何传递呢？用一下代码测试：](https://blog.csdn.net/qq_38410730/article/details/80895986)
       + 通过指针进行传递, 指针大小也是4字节, 所以最后还是通过eax进行

3. 寄存器的说明

   + eax是"累加器"（accumulator）, 它是很多加法乘法指令的缺省寄存器；

   + ebx 是"基地址"（base）寄存器, 在内存寻址时存放基地址；
   + ecx是计数器（counter）， 是重复（REP）前缀指令和LOOP指令的内定计数器；
   + edx则总是被用来放整数除法产生的余数。

### [问题三: C语言调用后如何返回到调用前的下一条指令执行?](https://www.cnblogs.com/findumars/p/7545818.html)

1. 类似于进行的切换: 有东西保存切换前的所有状态变量.
2. C函数中用于保存的是?**函数的堆栈帧** 
   + 函数的**堆栈帧**(Stack Frame) : 栈保存了一个函数调用所需要的维护信息;
3. **堆栈帧**保存了那几部分内容?
   + 函数的参数；函数的局部变量；寄存器的值（用以恢复寄存器）
   + 函数的返回地址以及用于结构化异常处理的数据（当函数中有try…catch语句时才有）等等
4. C语言调用后如何返回到调用前的下一条指令执行?
   + 函数的堆栈帧:  存放了**函数的返回地址**，即调用方调用此函数的下一条指令的地址。
   + 故而，在函数调用后，由函数调用方执行，直接返回调用前的下一条指令。