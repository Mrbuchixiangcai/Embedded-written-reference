## Linux 中断分层的概念

### Linux中断嵌套处理

1. Linux中断嵌套概念
   + 当一种类型的中断发生时, 又产生另外一种中断;
2. 慢速中断: 处理ISR函数时, **中断总开关不关闭**, 允许其他中断发生
   + 不同中断设备: 发生另外中断，**执行新的中断**，执行完成; 返回之前的中断处理函数继续执行
   + 相同类型设备: 发生另外中断，**忽略**发生的中断，继续执行之前的中断函数，造成中断丢失;
3. 快速中断:  处理ISR函数时, **中断总开关关闭**，不接受外部中断
   + 不同中断设备 : **忽略**发生的中断
   + 相同类型设备:  **忽略**发生的中断

### Linux 中断分层的原因

1. Linux 中断分层
   + 概念 : 将中断ISR分为前后两部分, 第一部分在中断函数中执行，第二部使用中断分层技术隔离出来。
   
   + 原因：ISR的执行并不存在于进程的上下文切换中, 要求ISR要尽可能短；
   
     ![interrupt_reason.png](https://github.com/quronghui/Embedded-written-reference/blob/master/OS/photo/interrupt_reason.png)
   
   + 作用: 减少中断处理函数执行时间，减少中断丢失的概率

### 实现中断底部的三种机制:

| 机制     | 软中断             | tasklet                             | 工作队列                           |
| -------- | ------------------ | ----------------------------------- | ---------------------------------- |
| 运行状态 |                    | 运行于中断上下文，不允许阻塞 、休眠 | 运行与进程上下文，可以休眠和阻塞。 |
| 多核执行 | 支持多核           | 同一个tasklet只能在一个CPU执行      |                                    |
| 分配方式 | 静态分配(不能改变) | 运行时改变                          |                                    |
| 调度函数 |                    | tasklet_schedule();                 | schedule_work();                   |

+ tasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。
+ 也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行

3. 软中断
   + 不同于软件中断
   + 软中断发生: 是从中断、调用或者异常返回用户空间之前; 
   + 执行顺序: 按照软中断在结构数组中定义的**顺序**依次执行;
   + 同一个软中断可以在不同CPU上**并发执行**, 软中断执行过程中**不允许睡眠和进程切换;**
2. tasklet
   + 基于软中断实现，在软中断结构数组中占用两项
   + 当中断执行到这两项时, 就会跳转到tasklet函数入口处，依次执行队列中的tasklet函数
   + 同一个tasklet**不能**在不同CPU上并发执行，但是不同tasklet可以在不同CPU上执行
3. 工作队列
   + 是一种将任务推后执行的形式，他把推后的任务交由一个**内核线程**去执行
   + 中断函数的第二部分会在进程上下文执行，它允许**重新调度甚至睡眠**。
   + 每个被推后的任务叫做“工作”，由这些工作组成的队列称为工作队列;