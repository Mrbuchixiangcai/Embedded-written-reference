## Linux中的锁

| 锁的机制 | 自旋锁                                     | 互斥锁               | 读写锁         | RCU                                 | 顺序锁             |
| -------- | ------------------------------------------ | -------------------- | -------------- | ----------------------------------- | ------------------ |
| lock     | spinlock                                   | mutexlock            | rwlock         | Read-Copy Update                    | seqlock            |
| 特性     | 循环-旋转-等待锁<br />忙等待               | 睡眠等待和唤醒       | 区分读和写     | 允许多个读-不加锁；<br />写需要加锁 | 对读写锁的一种优化 |
| 缺陷     | 自旋锁一直占用着CPU                        | 进程会睡眠           | 只允许一种状态 |                                     |                    |
|          | 阻塞等待，造成死锁：<br />copy_to_user()等 |                      |                |                                     |                    |
| 适用于   | 保持锁的时间较短的情况下                   | 防止资源读写竞争关系 |                | 多个读，少量写                      |                    |

### 互斥锁

1. 互斥体禁止多个线程同时进入受保护的代码“临界区”.
2. 在任意时刻，只有一个线程被允许进入这样的代码保护区。
3. 任何线程在进入临界区之前
   + 必须获取（acquire）与此区域相关联的互斥体的所有权。
   + 如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。
   + 这些线程必须等待，直到当前的属主线程释放（release）该互斥体
4. 什么时候需要使用互斥体呢？
   + 互斥体用于保护共享的易变代码，
   + 也就是，全局或静态数据。

### 自旋锁

1. 它是为实现保护共享资源而提出一种锁机制。
2. 自旋锁与互斥锁相同点?
   + 它们都是为了解决对某项资源的互斥使用。
   + 在任何时刻最多只能有一个执行单元获得锁。
3. 自旋锁与互斥锁不同点?
   + 两者在调度机制上略有不同。
   + 对于互斥锁，如果资源已经被占用，资源申请者只能进入**睡眠状态**。
   + 自旋锁: 调用者就一直循环, 等待锁的释放;
     