## [四种进程或线程同步互斥的控制方法](https://blog.csdn.net/bao_qibiao/article/details/4516196)

| 区别         | 临界区                         | 互斥量                                   | 信号量                                      | 事件             | 管程                         |
| ------------ | ------------------------------ | ---------------------------------------- | ------------------------------------------- | ---------------- | ---------------------------- |
| 目的         | 原子操作                       | 共享资源互斥                             | 共享资源同步                                | 同步             | 同步                         |
| 访问数据     | 任意时刻只有**一个线程**能访问 | 任意时刻只有**一个线程**能访问           | 多个线程同时                                | **等待**事件发生 | 同一时刻只允许**一个**访问者 |
| 多个线程     | **挂起**                       |                                          | 睡眠等待                                    |                  |                              |
| 临界区释放   | **抢占**                       |                                          | 按队列调度                                  |                  |                              |
| 操作原语     | 进入/离开 临界区               | 创建/打开/释放/等待                      | 同左                                        | 同左             |                              |
| MFC提供      | lock/unlock                    | CMutex                                   | sem_wait/sem_post                           | Event            |                              |
| **作用范围** | 同一进程的不同线程             | 同一进程的不同线程<br />跨进程的线程之间 | 不同进程的多个线程<br /> 同一进程的多个线程 | 跨进程           | 优化信号量；                 |

1. 同步和互斥？
   - 互斥：对于某一资源，同一时间只能由一个任务进行访问；
   - 同步：B任务的执行需要A任务返回一个事件才能继续执行；
2. 临界区和互斥量区别？
   + 互斥量是**可以命名**的，也就是说它可以**跨进程**使用；
   + 所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量

### 临界区（**Critical Section**）

1. 临界区：通过对多线程的**串行化**来访问**公共资源或一段代码**，速度快，适合控制数据访问。
2. 特性：
   + 保证在某一时刻只有一个**线程**能访问数据
   + 多个线程试图访问此临界区，将会被**挂起**，并一直持续到进入临界区的线程离开
   + 临界区在被释放后，其他线程可以继续**抢占**
   + 实现用**原子方式**操作共享资源的目的
3. 临界区包含两个操作原语：
   + EnterCriticalSection（） 进入临界区
   + LeaveCriticalSection（） 离开临界区
4. 作用范围：同一进程的不同线程
5. MFC实现实现临界区
   + MFC为临界区提供有一个 CCriticalSection类，实现临界区的同步；
   + 用CCriticalSection类成员函数Lock（）和UnLock（）标定出被保护代码片段

### 互斥量（**Mutex**）

1. 互斥量：为协调共同对一个共享资源的**单独访问**而设计的。
2. 特性：
   + 访问权限：**互斥量跟临界区很相似**，只有**拥有互斥对象**的线程才具有访问资源的**权限**
   + **互斥对象只有一个**：因此就决定了任何情况下此共享资源都不会同时被多个线程所访问
3. 互斥量的操作原语
   + CreateMutex（） **创建**一个互斥量
   + OpenMutex（） **打开**一个互斥量
   + ReleaseMutex（） **释放**互斥量
   + WaitForMultipleObjects（） **等待**互斥量对象
4. 互斥量和临界区的区别
   - 互斥不仅仅能够在**同一应用程序不同线程**中实现资源的安全共享
   - 而且可以在**不同应用程序的线程之间**实现对资源的安全共享。
5. MFC实现实现互斥量
   + MFC为互斥量提供有一个**CMutex**类；

### 信号量（**Semaphores**）

1. 信号量：为控制一个具有**有限数量**用户资源而设计。
2. 特性
   + 信号允许**多个线程同时**使用共享资源，限制在同一时刻访问此资源的**最大线程数目**
   + 信号量本质：就是一个计数器
   + PV操作：P操作--申请资源，sem减1；V操作--释放资源--sem加1
   + ![sem_pv.png](/OS/photo/sem_pv.png)
3. 信号量包含的几个操作原语：
   + CreateSemaphore（） 创建一个信号量
   + OpenSemaphore（） 打开一个信号量
   + ReleaseSemaphore（） 释放信号量
   + WaitForSingleObject（） 等待信号量

### 事 件

1. 事 件：用来**通知**线程有一些事件已发生，从而启动后继任务的开始。
2. 特性
   + 事件对象也可以通过**通知操作**的方式来保持**线程的同步**。并且可以实现不同进程中的线程同步操作。
3. 事 件包含的几个操作原语
   + CreateEvent（） 创建一个事件
   + OpenEvent（） 打开一个事件
   + SetEvent（） 回置事件
   + WaitForSingleObject（） 等待一个事件
   + WaitForMultipleObjects（） 等待多个事件

## 多线程并发的情况

1. 并发的情况？
   + 共享唯一的硬件设备
   + 共享同一块内存区域
   + 一个进程的运行依赖另一进程对共享资源的执行结果

### 管程的用法

1. Semaphore 机制的缺陷：
   + 程序的易读性相对较差，对于信号量的管理也分散在各个参与对象中；
   + 因此有可能引起**死锁，进程饿死**等问题
2. 管程的定义
   + 管程：是可以被多个进程/线程安全访问的对象或模块
   + 管程汇总的方法是受到Mutex保护的，意味着同一时刻只允许一个访问者来使用它们。
3. 管程的特性
   + 安全性；互斥性；共享性