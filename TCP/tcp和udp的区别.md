## TCP和UDP的区别

| 区别             | TCP                                            | UDP                                                          |
| ---------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 数据包分割与重组 | TCP层完成分割，目的主机TCP重组                 | 源路由器数据分割，目的主机重组                               |
| 连接             | 三次握手，四次挥手                             | 不建立连接                                                   |
| 数据单位         | 段（面向字节流）                               | 数据报                                                       |
| 丢包重试         | 丢包重发控制，顺序控制，超时重传，窗口流量控制 | 不会进行丢包重试，也不会纠正到达的顺序                       |
| 对应关系         | 一对一                                         | 支持一对一，一对多，多对一和多对多的交互通信                 |
| 头部开销         | 最小20字节                                     | 只有8字节                                                    |
| 拥塞控制         | 有控制                                         | 有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） |

### 熟知的端口号

![port.png](/TCP/photo/port.png)

### [TCP的三次握手](https://blog.csdn.net/qzcsu/article/details/72861891)

+ netstat -ant : 查看tcp的状态；
+ Synchronize Sequence Numbers

1. TCP 的通过三次握手过程
   
   + ![tcp_three.png](/TCP/photo/tcp_three.png)
   
   1. client : 发送SYN( syn_j = j )请求包给server; 并进入SYN_SEND状态,等待服务器确认;
   2. server: 收到请求并确认 , 发送ACK(ack = syn_j+1); 同时server发送一个SYN(syn_k = k); 并进入**SYN_RECV**状态;
   3. client: 收到SYN+ACK包, 向server发送ACK(ack = syn_k + 1); 
   4. client 和 server 同时进入**established**状态;
   
2. 为什么TCP客户端最后还要发送一次确认呢？
   - 防止已经**失效的连接**请求报文突然又传送到了服务器，从而产生错误
   - 防止服务器一直处于**SYN_RECV**，空等待客户端的报文；
   - **假设是两次握手建立连接**：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中**滞留的时间**太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时**重新**向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

### TCP四次挥手

1. TCP的四次挥手，断开连接过程？

   ![TCP_MSL.png](/TCP/photo/TCP_MSL.png)

2. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

   + **建立连接的时候：**服务器在**LISTEN**状态下，收到建立连接请求的**SYN**报文后，把ACK和SYN放在一个报文里发送给客户端。
+ **关闭连接时：**服务器收到对方的FIN报文时，**客户端不发数据但是还能接收数据**，
     + server可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
     + 也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

3. TCP第4次挥手client为何要等待2MSL才关闭？

   - MSL(Maximum Segment Lifetime)报文最大生存时间

     - 任何报文在网络上存活的最大时间，一旦超过该时间，报文就会被丢弃。
     - **TIME_WAIT = 2MSL**也就是指的2倍MSL的时间。
   - 保证client发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失;
   - **服务器**的角度：我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次；**客户端**在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

   + TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
   + 服务器每收到一次客户端的请求后都会**重新复位**这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔**75秒**发送一次。若一连发送**10个探测报文**仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### TCP 的窗口控制和重发控制

![tcp_flow.png](https://github.com/quronghui/Embedded-written-reference/blob/master/TCP/photo/tcp_flow.png)

### TCP的分包机制

1. TCP/ IP 数据传输中, 数据如何进行分包?
   - 按照最大的传输单元MTU进行计算;
   - 注意数据包需要包含首部